{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "stamp",
  "type": "registry:component",
  "title": "Stamp",
  "description": "Convert Any Image to beautiful Stamp",
  "registryDependencies": [],
  "files": [
    {
      "path": "registry/stamp/stamp.tsx",
      "content": "\"use client\"\r\n\r\nimport { useRef, useEffect, useState } from \"react\"\r\n\r\ninterface StampImageProps {\r\n  src: string\r\n  alt?: string\r\n  size?: number\r\n  className?: string\r\n  onLoad?: () => void\r\n  onError?: () => void\r\n  innerColor?: string // color for the inner part (background)\r\n  outerColor?: string // color for the outer part (border, perforation)\r\n}\r\n\r\nexport function StampImage({\r\n  src,\r\n  alt = \"Stamp image\",\r\n  size,\r\n  className = \"\",\r\n  onLoad,\r\n  onError,\r\n  innerColor = \"#ffffff\", // default to white\r\n  outerColor = \"#c0c0c0\", // default to gray\r\n}: StampImageProps) {\r\n  const canvasRef = useRef<HTMLCanvasElement>(null)\r\n  const [imgSize, setImgSize] = useState<{ width: number; height: number } | null>(null)\r\n\r\n  useEffect(() => {\r\n    if (!src) return\r\n\r\n    const img = new window.Image()\r\n    img.crossOrigin = \"anonymous\"\r\n\r\n    img.onload = () => {\r\n      setImgSize({ width: img.width, height: img.height })\r\n      onLoad?.()\r\n    }\r\n\r\n    img.onerror = () => {\r\n      onError?.()\r\n    }\r\n\r\n    img.src = src\r\n    // eslint-disable-next-line\r\n  }, [src])\r\n\r\n  useEffect(() => {\r\n    if (!src || !canvasRef.current || !imgSize) return\r\n\r\n    const canvas = canvasRef.current\r\n    const ctx = canvas.getContext(\"2d\")\r\n    if (!ctx) return\r\n\r\n    // Use actual image dimensions instead of forcing square\r\n    const baseWidth = size ? (size * imgSize.width) / Math.min(imgSize.width, imgSize.height) : imgSize.width\r\n    const baseHeight = size ? (size * imgSize.height) / Math.min(imgSize.width, imgSize.height) : imgSize.height\r\n    \r\n    const padding = 20\r\n    canvas.width = baseWidth + padding * 2\r\n    canvas.height = baseHeight + padding * 2\r\n\r\n    // Clear canvas\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height)\r\n\r\n    // Create stamp background (innerColor)\r\n    ctx.fillStyle = innerColor\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height)\r\n\r\n    // Draw the perforated border\r\n    drawPerforatedBorder(ctx, canvas.width, canvas.height, padding, outerColor)\r\n\r\n    // Draw the image at full size within the padding\r\n    const img = new window.Image()\r\n    img.crossOrigin = \"anonymous\"\r\n    img.onload = () => {\r\n      ctx.drawImage(img, padding, padding, baseWidth, baseHeight)\r\n    }\r\n    img.src = src\r\n  }, [src, size, imgSize, innerColor, outerColor])\r\n\r\n  const drawPerforatedBorder = (\r\n    ctx: CanvasRenderingContext2D,\r\n    width: number,\r\n    height: number,\r\n    padding: number,\r\n    borderColor: string\r\n  ) => {\r\n    const perfSize = 6\r\n    const perfSpacing = 11\r\n    const borderWidth = 9\r\n\r\n    // Draw outer border (outerColor)\r\n    ctx.strokeStyle = borderColor\r\n    ctx.lineWidth = borderWidth\r\n    ctx.strokeRect(borderWidth / 2, borderWidth / 2, width - borderWidth, height - borderWidth)\r\n\r\n    // Set perforation color\r\n    ctx.fillStyle = borderColor\r\n\r\n    // Draw perforations on all four sides\r\n    // Top edge\r\n    for (let x = padding; x < width - padding; x += perfSpacing) {\r\n      drawPerforation(ctx, x, padding / 2, perfSize, borderColor)\r\n    }\r\n\r\n    // Bottom edge\r\n    for (let x = padding; x < width - padding; x += perfSpacing) {\r\n      drawPerforation(ctx, x, height - padding / 2, perfSize, borderColor)\r\n    }\r\n\r\n    // Left edge\r\n    for (let y = padding; y < height - padding; y += perfSpacing) {\r\n      drawPerforation(ctx, padding / 2, y, perfSize, borderColor)\r\n    }\r\n\r\n    // Right edge\r\n    for (let y = padding; y < height - padding; y += perfSpacing) {\r\n      drawPerforation(ctx, width - padding / 2, y, perfSize, borderColor)\r\n    }\r\n\r\n    // Draw corner perforations\r\n    drawPerforation(ctx, padding / 2, padding / 2, perfSize, borderColor)\r\n    drawPerforation(ctx, width - padding / 2, padding / 2, perfSize, borderColor)\r\n    drawPerforation(ctx, padding / 2, height - padding / 2, perfSize, borderColor)\r\n    drawPerforation(ctx, width - padding / 2, height - padding / 2, perfSize, borderColor)\r\n  }\r\n\r\n  const drawPerforation = (\r\n    ctx: CanvasRenderingContext2D,\r\n    x: number,\r\n    y: number,\r\n    size: number,\r\n    color: string\r\n  ) => {\r\n    // Create a subtle gradient effect for the perforation\r\n    const gradient = ctx.createRadialGradient(x, y, 0, x, y, size / 2)\r\n    gradient.addColorStop(0, color)\r\n    gradient.addColorStop(1, color)\r\n    \r\n    ctx.fillStyle = gradient\r\n    ctx.beginPath()\r\n    ctx.arc(x, y, size / 2, 0, Math.PI * 2)\r\n    ctx.fill()\r\n    \r\n    // Add a subtle border to make the dot more defined\r\n    ctx.strokeStyle = color\r\n    ctx.lineWidth = 0.5\r\n    ctx.stroke()\r\n  }\r\n\r\n  return (\r\n    <canvas\r\n      ref={canvasRef}\r\n      className={`max-w-full h-auto ${className}`}\r\n      style={{\r\n        filter: \"drop-shadow(0 10px 20px rgba(0, 0, 0, 0.1))\",\r\n        background: innerColor,\r\n      }}\r\n      aria-label={alt}\r\n    />\r\n  )\r\n}\r\n",
      "type": "registry:component"
    }
  ]
}