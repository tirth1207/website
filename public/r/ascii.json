{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ascii",
  "type": "registry:component",
  "title": "Ascii",
  "description": "Convert Any Image to Ascii",
  "registryDependencies": [],
  "files": [
    {
      "path": "registry/ascii/ascii.tsx",
      "content": "\"use client\"\r\n\r\nimport React, { useRef, useState, useEffect, useCallback } from \"react\"\r\n\r\n// ASCII character sets for different rendering modes\r\nconst ASCII_MODES = {\r\n  classic: \"@$B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/|()1{}[]?-_+~<>i!lI;:,\\\"^`'. \",\r\n  blocks: \"██▓▒░ \",\r\n  shades: \"██▓▒░  \",\r\n  numbers: \"9876543210 \",\r\n  alphanumeric: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 \",\r\n  minimal: \"█▌ \",\r\n  detailed: \"@%#*+=-:. \",\r\n  pixel: \"██▀▄ \"\r\n} as const\r\n\r\ntype AsciiMode = keyof typeof ASCII_MODES\r\ntype ColorMode = 'none' | 'color' | 'grayscale'\r\ntype Theme = 'light' | 'dark' | 'auto'\r\n\r\ninterface AsciiImageProps {\r\n  src: string\r\n  alt?: string\r\n  width?: number\r\n  height?: number\r\n  mode?: AsciiMode\r\n  colorMode?: ColorMode\r\n  theme?: Theme\r\n  gamma?: number\r\n  dithering?: boolean\r\n  aspectRatio?: number\r\n  fitToContainer?: boolean\r\n  maxWidth?: number\r\n  maxHeight?: number\r\n  className?: string\r\n  style?: React.CSSProperties\r\n  onLoad?: () => void\r\n  onError?: (error: Error) => void\r\n}\r\n\r\nexport const AsciiImage: React.FC<AsciiImageProps> = ({\r\n  src,\r\n  alt = \"ASCII converted image\",\r\n  width = 80,\r\n  height,\r\n  mode = 'classic',\r\n  colorMode = 'none',\r\n  theme = 'auto',\r\n  gamma = 1.0,\r\n  dithering = true,\r\n  aspectRatio = 0.5,\r\n  fitToContainer = true,\r\n  maxWidth,\r\n  maxHeight,\r\n  className = '',\r\n  style = {},\r\n  onLoad,\r\n  onError,\r\n}) => {\r\n  const canvasRef = useRef<HTMLCanvasElement>(null)\r\n  const containerRef = useRef<HTMLDivElement>(null)\r\n  const imageRef = useRef<HTMLImageElement>(null)\r\n  const resizeObserverRef = useRef<ResizeObserver>(null)\r\n\r\n  const [ascii, setAscii] = useState<string>(\"\")\r\n  const [isLoading, setIsLoading] = useState<boolean>(true)\r\n  const [error, setError] = useState<string | null>(null)\r\n  const [imageDimensions, setImageDimensions] = useState({ width: 0, height: 0 })\r\n  const [containerSize, setContainerSize] = useState({ width: 0, height: 0 })\r\n  const [calculatedDimensions, setCalculatedDimensions] = useState({ width: width, height: height || 0 })\r\n  const [currentTheme, setCurrentTheme] = useState<'light' | 'dark'>('light')\r\n\r\n  // Get mode-specific aspect ratio for better character rendering\r\n  const getModeAspectRatio = useCallback((mode: AsciiMode): number => {\r\n    switch (mode) {\r\n      case 'blocks':\r\n        return 0.5 // Block characters\r\n      case 'pixel':\r\n      case 'shades':\r\n        return 0.5 // Standard block aspect ratio\r\n      default:\r\n        return aspectRatio // Use provided aspect ratio for other modes\r\n    }\r\n  }, [aspectRatio])\r\n\r\n  const effectiveAspectRatio = getModeAspectRatio(mode)\r\n\r\n  // Detect system theme\r\n  useEffect(() => {\r\n    if (theme === 'auto') {\r\n      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')\r\n      setCurrentTheme(mediaQuery.matches ? 'dark' : 'light')\r\n      \r\n      const handleChange = (e: MediaQueryListEvent) => {\r\n        setCurrentTheme(e.matches ? 'dark' : 'light')\r\n      }\r\n      \r\n      mediaQuery.addEventListener('change', handleChange)\r\n      return () => mediaQuery.removeEventListener('change', handleChange)\r\n    } else {\r\n      setCurrentTheme(theme)\r\n    }\r\n  }, [theme])\r\n\r\n  // Floyd–Steinberg dithering\r\n  const floydSteinberg = useCallback((grayMap: number[][], width: number, height: number, levels: number) => {\r\n    const copy = grayMap.map(row => [...row])\r\n    for (let y = 0; y < height; y++) {\r\n      for (let x = 0; x < width; x++) {\r\n        const oldPixel = copy[y][x]\r\n        const newPixel = Math.round((levels - 1) * oldPixel) / (levels - 1)\r\n        copy[y][x] = newPixel\r\n        const quantError = oldPixel - newPixel\r\n\r\n        if (x + 1 < width) copy[y][x + 1] += quantError * (7 / 16)\r\n        if (y + 1 < height) {\r\n          if (x > 0) copy[y + 1][x - 1] += quantError * (3 / 16)\r\n          copy[y + 1][x] += quantError * (5 / 16)\r\n          if (x + 1 < width) copy[y + 1][x + 1] += quantError * (1 / 16)\r\n        }\r\n      }\r\n    }\r\n    return copy\r\n  }, [])\r\n\r\n  // Calculate responsive dimensions\r\n  const calculateResponsiveDimensions = useCallback(() => {\r\n    if (!imageDimensions.width || !imageDimensions.height) {\r\n      return { width: width, height: height || Math.floor(width * 0.75) }\r\n    }\r\n\r\n    if (!fitToContainer) {\r\n      // When not fitting to container, use image dimensions to calculate ASCII size\r\n      const imageAspectRatio = imageDimensions.width / imageDimensions.height\r\n      \r\n      if (width && !height) {\r\n        // Only width specified, calculate height from aspect ratio\r\n        const targetHeight = Math.floor(width / (imageAspectRatio * effectiveAspectRatio))\r\n        return { width, height: targetHeight }\r\n      } else if (!width && height) {\r\n        // Only height specified, calculate width from aspect ratio\r\n        const targetWidth = Math.floor(height * imageAspectRatio * effectiveAspectRatio)\r\n        return { width: targetWidth, height }\r\n      } else if (width && height) {\r\n        // Both specified, use as-is\r\n        return { width, height }\r\n      } else {\r\n        // Neither specified, calculate from image size with a reasonable scale\r\n        const scale = Math.min(120 / imageDimensions.width, 80 / imageDimensions.height)\r\n        const targetWidth = Math.floor(imageDimensions.width * scale)\r\n        const targetHeight = Math.floor(imageDimensions.height * scale / effectiveAspectRatio)\r\n        return { width: targetWidth, height: targetHeight }\r\n      }\r\n    }\r\n\r\n    // Fit to container logic - simplified and more reliable\r\n    if (!containerSize.width || !containerSize.height) {\r\n      return { width: 100, height: 60 }\r\n    }\r\n\r\n    const imageAspectRatio = imageDimensions.width / imageDimensions.height\r\n    \r\n    // Calculate dimensions that will fit in container while maintaining aspect ratio\r\n    // Start with a reasonable base size and scale to container\r\n    let targetCols = Math.min(120, Math.max(40, Math.floor(containerSize.width / 8)))\r\n    let targetRows = Math.floor(targetCols / (imageAspectRatio * effectiveAspectRatio))\r\n    \r\n    // Ensure minimum viable dimensions\r\n    targetCols = Math.max(targetCols, 20)\r\n    targetRows = Math.max(targetRows, 15)\r\n\r\n    if (maxWidth) targetCols = Math.min(targetCols, maxWidth)\r\n    if (maxHeight) targetRows = Math.min(targetRows, maxHeight)\r\n\r\n    return { width: targetCols, height: targetRows }\r\n  }, [fitToContainer, width, height, imageDimensions, containerSize, effectiveAspectRatio, maxWidth, maxHeight])\r\n\r\n  // Container resize observer\r\n  useEffect(() => {\r\n    if (!containerRef.current || !fitToContainer) return\r\n\r\n    if (resizeObserverRef.current) {\r\n      resizeObserverRef.current.disconnect()\r\n    }\r\n\r\n    // @ts-expect-error: workaround for readonly ref\r\n    resizeObserverRef.current = new ResizeObserver((entries) => {\r\n      for (const entry of entries) {\r\n        const { width, height } = entry.contentRect\r\n        // Ensure minimum container size for proper rendering\r\n        if (width > 10 && height > 10) {\r\n          setContainerSize({ width, height })\r\n        }\r\n      }\r\n    })\r\n\r\n    resizeObserverRef.current.observe(containerRef.current)\r\n\r\n    // Set initial container size\r\n    const rect = containerRef.current.getBoundingClientRect()\r\n    if (rect.width > 10 && rect.height > 10) {\r\n      setContainerSize({ width: rect.width, height: rect.height })\r\n    }\r\n\r\n    return () => {\r\n      if (resizeObserverRef.current) {\r\n        resizeObserverRef.current.disconnect()\r\n      }\r\n    }\r\n  }, [fitToContainer])\r\n\r\n  // Update calculated dimensions\r\n  useEffect(() => {\r\n    const newDimensions = calculateResponsiveDimensions()\r\n    setCalculatedDimensions(prev => {\r\n      if (prev.width !== newDimensions.width || prev.height !== newDimensions.height) {\r\n        return newDimensions\r\n      }\r\n      return prev\r\n    })\r\n  }, [calculateResponsiveDimensions])\r\n\r\n  // Convert pixels to ASCII with mode-specific optimizations\r\n  const processImageToAscii = useCallback((imageData: ImageData, width: number, height: number) => {\r\n    const { data } = imageData\r\n    const charSet = ASCII_MODES[mode]\r\n    let grayMap: number[][] = []\r\n\r\n    // Create grayscale map\r\n    for (let y = 0; y < height; y++) {\r\n      grayMap[y] = []\r\n      for (let x = 0; x < width; x++) {\r\n        const idx = (y * width + x) * 4\r\n        const r = data[idx]\r\n        const g = data[idx + 1]\r\n        const b = data[idx + 2]\r\n        let brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255\r\n        \r\n        // Mode-specific gamma adjustments for better visibility\r\n        if (mode === 'blocks') {\r\n          brightness = Math.pow(brightness, gamma * 0.8) // Slightly reduce gamma for block mode\r\n        } else {\r\n          brightness = Math.pow(brightness, gamma)\r\n        }\r\n        grayMap[y][x] = brightness\r\n      }\r\n    }\r\n\r\n    // Apply dithering if enabled\r\n    if (dithering) {\r\n      grayMap = floydSteinberg(grayMap, width, height, charSet.length)\r\n    }\r\n\r\n    // Generate ASCII output\r\n    let output = \"\"\r\n    for (let y = 0; y < height; y++) {\r\n      for (let x = 0; x < width; x++) {\r\n        const idx = (y * width + x) * 4\r\n        const r = data[idx]\r\n        const g = data[idx + 1]\r\n        const b = data[idx + 2]\r\n\r\n        const val = grayMap[y][x]\r\n        \r\n        // Improved character mapping for special modes\r\n        let charIndex: number\r\n        if (mode === 'blocks') {\r\n          // More aggressive mapping for high-contrast modes\r\n          const enhancedVal = Math.pow(val, 0.7) // Enhance contrast\r\n          charIndex = Math.floor((charSet.length - 1) * (1 - enhancedVal))\r\n        } else {\r\n          charIndex = Math.floor((charSet.length - 1) * (1 - val))\r\n        }\r\n        \r\n        const char = charSet[Math.max(0, Math.min(charIndex, charSet.length - 1))] || \" \"\r\n\r\n        if (colorMode === 'color') {\r\n          let escapedChar = char\r\n          if (char === \"<\") escapedChar = \"&lt;\"\r\n          else if (char === \">\") escapedChar = \"&gt;\"\r\n          else if (char === \"&\") escapedChar = \"&amp;\"\r\n          output += `<span style=\"color:rgb(${r},${g},${b})\">${escapedChar}</span>`\r\n        } else if (colorMode === 'grayscale') {\r\n          const gray = Math.floor(0.299 * r + 0.587 * g + 0.114 * b)\r\n          let escapedChar = char\r\n          if (char === \"<\") escapedChar = \"&lt;\"\r\n          else if (char === \">\") escapedChar = \"&gt;\"\r\n          else if (char === \"&\") escapedChar = \"&amp;\"\r\n          output += `<span style=\"color:rgb(${gray},${gray},${gray})\">${escapedChar}</span>`\r\n        } else {\r\n          output += char\r\n        }\r\n      }\r\n      output += \"\\n\"\r\n    }\r\n\r\n    setAscii(output)\r\n  }, [mode, colorMode, gamma, dithering, floydSteinberg])\r\n\r\n  // Render ASCII from image\r\n  const renderAscii = useCallback(() => {\r\n    if (!imageRef.current || !canvasRef.current || !imageRef.current.complete) return\r\n\r\n    const image = imageRef.current\r\n    const canvas = canvasRef.current\r\n    const ctx = canvas.getContext(\"2d\", { willReadFrequently: true })\r\n    if (!ctx) return\r\n\r\n    const w = image.naturalWidth\r\n    const h = image.naturalHeight\r\n\r\n    if (w === 0 || h === 0) return\r\n\r\n    setImageDimensions(prev => {\r\n      if (prev.width !== w || prev.height !== h) {\r\n        return { width: w, height: h }\r\n      }\r\n      return prev\r\n    })\r\n\r\n    const asciiWidth = Math.max(1, calculatedDimensions.width)\r\n    const asciiHeight = Math.max(1, calculatedDimensions.height)\r\n\r\n    if (asciiWidth === 0 || asciiHeight === 0) return\r\n\r\n    canvas.width = asciiWidth\r\n    canvas.height = asciiHeight\r\n\r\n    try {\r\n      ctx.drawImage(image, 0, 0, asciiWidth, asciiHeight)\r\n      const imageData = ctx.getImageData(0, 0, asciiWidth, asciiHeight)\r\n      processImageToAscii(imageData, asciiWidth, asciiHeight)\r\n    } catch (err) {\r\n      // Handle CORS/tainted canvas by trying without crossOrigin\r\n      if (err instanceof Error && err.name === 'SecurityError') {\r\n        console.warn('CORS issue detected, trying to reload image without crossOrigin...')\r\n        \r\n        // Create a new image without crossOrigin\r\n        const fallbackImg = new Image()\r\n        fallbackImg.onload = () => {\r\n          try {\r\n            const fallbackCanvas = document.createElement('canvas')\r\n            const fallbackCtx = fallbackCanvas.getContext('2d', { willReadFrequently: true })\r\n            if (!fallbackCtx) return\r\n            \r\n            fallbackCanvas.width = asciiWidth\r\n            fallbackCanvas.height = asciiHeight\r\n            fallbackCtx.drawImage(fallbackImg, 0, 0, asciiWidth, asciiHeight)\r\n            \r\n            const fallbackImageData = fallbackCtx.getImageData(0, 0, asciiWidth, asciiHeight)\r\n            processImageToAscii(fallbackImageData, asciiWidth, asciiHeight)\r\n          } catch (fallbackErr) {\r\n            const error = new Error(`Failed to process image after fallback: ${fallbackErr}`)\r\n            setError(error.message)\r\n            onError?.(error)\r\n          }\r\n        }\r\n        fallbackImg.onerror = () => {\r\n          const error = new Error('Failed to load image without CORS')\r\n          setError(error.message)\r\n          onError?.(error)\r\n        }\r\n        fallbackImg.src = src\r\n      } else {\r\n        const error = new Error(`Failed to process image: ${err}`)\r\n        setError(error.message)\r\n        onError?.(error)\r\n      }\r\n    }\r\n  }, [calculatedDimensions, processImageToAscii, onError, src])\r\n\r\n  // Handle image load/error\r\n  useEffect(() => {\r\n    if (!imageRef.current) return\r\n\r\n    const image = imageRef.current\r\n\r\n    const handleLoad = () => {\r\n      setIsLoading(false)\r\n      setError(null)\r\n      \r\n      // Set image dimensions first\r\n      const w = image.naturalWidth\r\n      const h = image.naturalHeight\r\n      if (w > 0 && h > 0) {\r\n        setImageDimensions({ width: w, height: h })\r\n        \r\n        // Set container size for non-fitting containers\r\n        if (!fitToContainer) {\r\n          setContainerSize({ width: w, height: h })\r\n        }\r\n      }\r\n\r\n      // Delay rendering to ensure dimensions are set\r\n      setTimeout(renderAscii, 100)\r\n      onLoad?.()\r\n    }\r\n\r\n    const handleError = () => {\r\n      setIsLoading(false)\r\n      const error = new Error(`Failed to load image: ${src}`)\r\n      setError(error.message)\r\n      onError?.(error)\r\n    }\r\n\r\n    image.addEventListener('load', handleLoad)\r\n    image.addEventListener('error', handleError)\r\n\r\n    if (image.complete && image.naturalWidth > 0) {\r\n      handleLoad()\r\n    }\r\n\r\n    return () => {\r\n      image.removeEventListener('load', handleLoad)\r\n      image.removeEventListener('error', handleError)\r\n    }\r\n  }, [src, renderAscii, fitToContainer, onLoad, onError])\r\n\r\n  // Recalculate on dependency changes\r\n  useEffect(() => {\r\n    if (!isLoading && !error && imageRef.current?.complete) {\r\n      renderAscii()\r\n    }\r\n  }, [mode, colorMode, gamma, dithering, calculatedDimensions, renderAscii, isLoading, error])\r\n\r\n  // Calculate styles for proper rendering\r\n  const getStyles = () => {\r\n    let fontSize = 8 // Default font size\r\n    let lineHeight = \"1.0\"\r\n    let letterSpacing = \"0px\"\r\n\r\n    if (fitToContainer && containerSize.width > 0 && containerSize.height > 0 && calculatedDimensions.width > 0 && calculatedDimensions.height > 0) {\r\n      // Calculate font size to fit container\r\n      const charWidth = 0.6 // Approximate character width in em\r\n      const cols = calculatedDimensions.width\r\n      const rows = calculatedDimensions.height\r\n      \r\n      // Calculate font size that fits both width and height\r\n      const fontSizeFromWidth = containerSize.width / (cols * charWidth)\r\n      const fontSizeFromHeight = containerSize.height / rows\r\n      \r\n      fontSize = Math.max(4, Math.min(fontSizeFromWidth, fontSizeFromHeight))\r\n      \r\n      // Adjust line height for better fitting\r\n      lineHeight = mode === 'blocks' ? \"0.9\" : \"1.0\"\r\n      \r\n      // Calculate letter spacing to fill width exactly\r\n      const actualCharWidth = fontSize * charWidth\r\n      const totalUsedWidth = actualCharWidth * cols\r\n      const leftoverWidth = containerSize.width - totalUsedWidth\r\n      if (leftoverWidth > 0 && cols > 1) {\r\n        letterSpacing = `${leftoverWidth / (cols - 1)}px`\r\n      }\r\n    }\r\n\r\n    const baseStyle = {\r\n      fontFamily: \"'Courier New', Consolas, 'Lucida Console', Monaco, monospace\",\r\n      fontSize: `${fontSize}px`,\r\n      lineHeight: lineHeight,\r\n      letterSpacing: letterSpacing,\r\n      whiteSpace: \"pre\" as const,\r\n      margin: 0,\r\n      padding: 0,\r\n      width: fitToContainer ? \"100%\" : \"auto\",\r\n      height: fitToContainer ? \"100%\" : \"auto\",\r\n      overflow: \"hidden\" as const,\r\n      display: \"block\" as const,\r\n      boxSizing: \"border-box\" as const,\r\n    }\r\n\r\n    if (colorMode !== 'none') {\r\n      return baseStyle\r\n    }\r\n\r\n    return {\r\n      ...baseStyle,\r\n      color: currentTheme === 'dark' ? '#ffffff' : '#000000',\r\n      backgroundColor: 'transparent',\r\n    }\r\n  }\r\n\r\n  if (error) {\r\n    return (\r\n      <div className={className} style={style}>\r\n        <div style={{ \r\n          color: currentTheme === 'dark' ? '#ff6b6b' : '#dc3545', \r\n          fontFamily: 'monospace',\r\n          padding: '1rem',\r\n          textAlign: 'center'\r\n        }}>\r\n          Error: {error}\r\n        </div>\r\n      </div>\r\n    )\r\n  }\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={className}\r\n      style={{\r\n        width: fitToContainer ? \"100%\" : \"auto\",\r\n        height: fitToContainer ? \"100%\" : \"auto\",\r\n        display: \"block\",\r\n        overflow: fitToContainer ? \"hidden\" : \"visible\",\r\n        backgroundColor: currentTheme === 'dark' ? '#1a1a1a' : '#ffffff',\r\n        border: `1px solid ${currentTheme === 'dark' ? '#333' : '#ccc'}`,\r\n        minWidth: fitToContainer ? \"200px\" : \"auto\",\r\n        minHeight: fitToContainer ? \"150px\" : \"auto\",\r\n        ...style\r\n      }}\r\n    >\r\n      <canvas ref={canvasRef} style={{ display: \"none\" }} />\r\n      <img\r\n        ref={imageRef}\r\n        src={src}\r\n        alt={alt}\r\n        style={{ display: \"none\" }}\r\n        crossOrigin=\"anonymous\"\r\n      />\r\n      \r\n      {isLoading ? (\r\n        <div style={{ \r\n          color: currentTheme === 'dark' ? '#ffffff' : '#000000',\r\n          fontFamily: 'monospace',\r\n          padding: '1rem',\r\n          textAlign: 'center'\r\n        }}>\r\n          Loading...\r\n        </div>\r\n      ) : ascii ? (\r\n        colorMode !== 'none' ? (\r\n          <pre\r\n            style={getStyles()}\r\n            dangerouslySetInnerHTML={{ __html: ascii }}\r\n          />\r\n        ) : (\r\n          <pre style={getStyles()}>\r\n            {ascii}\r\n          </pre>\r\n        )\r\n      ) : (\r\n        <div style={{ \r\n          color: currentTheme === 'dark' ? '#888' : '#666',\r\n          fontFamily: 'monospace',\r\n          padding: '1rem',\r\n          textAlign: 'center'\r\n        }}>\r\n          No ASCII generated\r\n        </div>\r\n      )}\r\n    </div>\r\n  )\r\n}\r\n",
      "type": "registry:component"
    }
  ]
}